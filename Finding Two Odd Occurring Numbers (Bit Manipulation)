üß† MIND MAP: Finding Two Odd Occurring Numbers (Bit Manipulation)

üéØ GOAL: Find 2 numbers that occur odd number of times in an array
         (All others occur even number of times)

1Ô∏è‚É£ XOR ALL ELEMENTS
   - Purpose: Cancel out even occurrences
   - Code:
     xorResult = 0
     for each arr[i]: xorResult ^= arr[i]
   - Result: xorResult = num1 ^ num2

2Ô∏è‚É£ FIND RIGHTMOST SET BIT
   - Purpose: Identify a bit where num1 and num2 differ
   - Code:
     firstSetBit = 1
     while ((xorResult & firstSetBit) == 0):
         firstSetBit <<= 1
   - Alternative (faster): firstSetBit = xorResult & -xorResult

3Ô∏è‚É£ SPLIT ELEMENTS INTO TWO GROUPS
   - Group A: arr[i] where (arr[i] & firstSetBit) ‚Üí bit is 1
   - Group B: arr[i] where (arr[i] & firstSetBit) == 0 ‚Üí bit is 0
   - XOR each group:
     - Group A ‚Üí n1 ^= arr[i]
     - Group B ‚Üí n2 ^= arr[i]
   - Now: n1 and n2 are the two odd occurring numbers

4Ô∏è‚É£ SORT RESULTS
   - Store in vector `v`
   - Ensure descending order (as per some problem specs):
     if v[0] < v[1]: swap(v[0], v[1])

5Ô∏è‚É£ RETURN VECTOR
   - return v;


üß† Mnemonic to Remember Steps:

"XOR ‚Äì BIT ‚Äì SPLIT ‚Äì FIND ‚Äì SORT ‚Äì RETURN"

1-XOR all numbers to cancel evens

2-Find rightmost set BIT to separate num1 and num2

3-SPLIT array based on that bit

4-FIND the two odd ones by XOR-ing groups

5-SORT (if needed)

6-RETURN the result

üß† Tip:
You can visualize the array splitting like this:

Example: arr = [4, 2, 4, 5, 2, 3, 3, 1]

After XOR ‚Üí xorResult = 5 ^ 1 = 4 (binary: 0100)

‚Üí firstSetBit = 0100 (bit at position 2)

Now group elements:
Group A (bit 2 = 1): [4, 4, 5]
Group B (bit 2 = 0): [2, 2, 3, 3, 1]

XOR each group:
Group A ‚Üí 4 ^ 4 ^ 5 = 5
Group B ‚Üí 2 ^ 2 ^ 3 ^ 3 ^ 1 = 1


